#!/bin/bash

#############
# Functions #
#############

# Get name of directory
function get_name {
	echo "$@" | grep -Eo '[^\/]+$'
}

# Logging
function out {
	[ $1 -le $verbosity ] && echo "$2"
}

# Print help page
function show_help {
echo "
Usage: $0 [-hrvpus] [-t interval] [-e command] TARGET_DIR[.tar.gz]

Technical:
 -h		- Show this page.
 -v		- Show info messages.

Mount Settings:
 TARGET_DIR	- Path or name of directory that will be moved to tmpfs.

 -t interval	- Synchronize interval in seconds (default: 30, 0 to disable).
		  
 -p		- Do not delete directory from tmpfs after unmounting.
 -pp		- Similar to -p and do not delete files unpacked from archive.
		  
 -r		- Mount read only. Any changes in a tmpfs copy will not be
		  saved after unmounting. [DANGEROUS]

 -s		- Send SIGSTOP and SIGCONT to all processes which are using
		  the target directory.

Execute scripts:
 -e command	- Execute this command after moving directory to tmpfs.
		  When command is finished, directory will be moved back.

Mount control:
 -u		- Unmount directory.
"
}

# Check parameters
if [ $# -eq 0 ]; then
	show_help
	exit 1
fi

# Defaults
verbosity=0
sync_interval=30

# Parsing arguments
while getopts ":t:e:rhvpus" opt; do
	case $opt in
		t) sync_interval="$OPTARG";;
		e) execute="$OPTARG" ;;
		r) read_only="true" ;;
		v) verbosity=$((verbosity+1)) ;;
		p) if [ "$save_ram_copy" ]; then
			save_disk_copy="true"
		   else
			save_ram_copy="true"
		   fi
		   ;;
		u) unmount="true" ;;
		s) send_signals="true" ;;
			
		*) show_help; exit ;;
	esac
done
shift $((OPTIND-1))

##############
# Initialize #
##############

# Find path to the biggest mounted tmpfs
tmpfs_mounts=$(mount | grep tmpfs | awk '{print $3}')
tmpfs_max_size=0
for tmpfs in $tmpfs_mounts; do
	size=$(df --output=avail "$tmpfs" | grep -Eo "[0-9]*")
	if [ $size -gt $tmpfs_max_size ] && \
	   touch "$tmpfs/tmpfize-test" > /dev/null 2>&1 && \
	   rm "$tmpfs/tmpfize-test" > /dev/null 2>&1
	then
		tmpfs_max_size=$size
		tmpfize=$tmpfs
	fi
done

# Check for successfully found path to tmpfs
[ ! "$tmpfize" ] && out 0 "[Error] Tmpfs not found..." && exit 1
out 1 "[Info] Using tmpfs mounted in $tmpfize (size: $tmpfs_max_size KB)"

# Target directory
target_dir=$(realpath -s "$1") # /path/to/dir

# Check for archive extension
if echo "$target_dir" | grep -qE ".tar.gz$"; then
	archive="true"
	target_dir=$(echo "$target_dir" | sed 's/.tar.gz$//g')
fi

target_dir_path=$(echo "$target_dir" | grep -Eo '^.*\/') # /path/to/
target_dir_name=$(get_name "$target_dir") # dir
target_dir_id=$(echo "$target_dir" | md5sum | grep -Eo "^[a-z0-9]+")

# Generating paths
target_tmpfs="$tmpfize/tmpfize.$target_dir_id"
backup_dir="$target_dir_path/.tmpfize.$target_dir_id.$target_dir_name"
target_marker="$target_dir/.tmpfize"

#############
# Functions #
#############

# Unmount previously mounted directory
if [ "$unmount" ]; then
	if [ -e "$target_marker" ]; then
		rm "$target_marker"

		out 1 "Waiting until directory is unmouted..."
		while [ -e "$backup_dir" ] || [ -e "$target_marker.packing" ]; do
			sleep 1;
		done
	else
		out 0 "[Error] Directory $target_dir_name is not mounted!"
	fi
	
	exit 0
fi

# Back sequence
function back_sequence {
	if [ "$1" -ge 5 ]; then
		send_signal STOP
		[ ! "$read_only" ] \
			&& rsync -ax --delete "$target_tmpfs/" "$backup_dir"
	fi

	if [ "$1" -ge 4 ]; then
		rm "$target_dir"
		mv "$backup_dir" "$target_dir"
	fi
	
	if [ "$1" -eq 3 ]; then
		rsync -ax "$backup_dir/" "$target_dir"
		rm -r "$backup_dir"
	fi

	if [ "$1" -ge 2 ]; then
		[ ! "$save_ram_copy" ] && rm -r "$target_tmpfs"
		
		send_signal CONT
	fi

	if [ "$1" -ge 1 ]; then
		if [ "$archive" == "true" ] && [ "$read_only" != "true" ]; then
			touch "$target_marker.packing"
			tar \
				-czf "$target_dir.tar.gz"\
				-C "$target_dir_path" \
				--exclude=".tmpfize*" \
				"$target_dir_name"
			rm "$target_marker.packing"
			
			[ "$save_disk_copy" ] || rm -r "$target_dir"
		fi
	
		[ "$1" -lt 5 ] && exit 1
	fi
}

# Background synchronization
function background_sync {
	count=0
	while [ -e "$target_marker" ]; do
		if [ ! "$read_only" ] && [ "$sync_interval" -gt 0 ]; then
			if [ "$count" -lt "$sync_interval" ]; then
				count=$((count+1))
			else
				rsync -ax --delete \
					--exclude $(get_name "$target_marker") \
					"$target_dir/" "$backup_dir"
				count=0
			fi
		fi
		sleep 1
	done
	
	back_sequence 5
}

# Run process and keep tmpfize alive until it finishes
function process_watcher {
	if [ "$execute" ]; then
		out 1 "[Info] Starting command ($execute)"
		$execute > /dev/null 2>&1
		[ -e "$target_marker" ] && rm "$target_marker"
	fi
}

# Send signals to processes which are using target directory
function send_signal {
	SIG="$1"

	[ ! "$send_signals" ] && return 0
	
	# Looking for PIDs with fuser
	export PID_list="$PID_list $(fuser "$target_dir" 2>&1 \
		| sed -e 's/.*\: //g' -e 's/[a-z]*//g')"
	
	# Send signal to each process
	for PID in $PID_list; do
		kill -SIG$SIG $PID > /dev/null 2>&1
		
		# Delete dead processes from list
		if [ $? == 1 ]; then
			export PID_list=$(echo "$PID_list" | sed "s/$PID//g")
		fi
	done
}

###############################
# Moving $target_dir to tmpfs #
###############################

# Level 1: Check if directory is already mouted
out 1 "[Info] Checking if $target_dir_name is already mounted"
if [ -e "$target_marker" ]; then
	out 0 "[Error] $target_dir is already mounted!"
	
	back_sequence 1
fi

# Restore backup if exists and create if not
out 1 "[Info] Checking if backup of $target_dir_name exists"
if [ -e "$backup_dir" ]; then
	out 0 "[Warning] Backup of $target_dir_name is found. Restoring..."

	if [ ! -d "$target_dir" ]; then
		rm "$target_dir"
		mv "$backup_dir" "$target_dir"
	else
		rsync -ax "$backup_dir/" "$target_dir" \
			&& rm -r "$backup_dir"
	fi
fi
[ ! -e "$target_dir" ] && mkdir -p "$target_dir"

# Check free space in tmpfs
target_dir_size=$(du -s "$target_dir" | awk '{print $1}' || echo 0)

if [ $target_dir_size -ge $tmpfs_max_size ]; then
	out 0 "[Error] Not enough space in tmpfs!"
	exit 1
fi

# Unpack archive if passed as main argument
if [ "$archive" == "true" ]; then
	if [ -e "$target_dir.tar.gz" ]; then
		out 1 "[Info] Unpacking archive $target_dir_name.tar.gz"
		if ! tar --keep-newer-files -xzf "$target_dir.tar.gz" -C "$target_dir_path"; then
			out 0 "[Error] Can't unpack archive $target_dir_name.tar.gz!"

			back_sequence 2
		fi
	else
		out 1 "[Info] Archive $target_dir_name.tar.gz not found. It will be created after unmount"
	fi
fi

# Level 2: Copying files from target directory to tmpfs
out 1 "[Info] Copying files from $target_dir_name to tmpfs"
send_signal STOP
if ! rsync -ax --delete "$target_dir/" "$target_tmpfs"; then
	out 0 "[Error] Can't copy $target_dir_name to tmpfs!"

	back_sequence 2
fi

# Level 3: Moving target directory from the way
out 1 "[Info] Renaming $target_dir_name to $(get_name $backup_dir)"
if ! mv "$target_dir" "$backup_dir"; then
	out 0 "[Error] Can't move $target_dir_name to $(get_name $backup_dir)"
	
	back_sequence 3
fi

# Level 4: Mounting tmpfs into target directory
out 1 "[Info] Creating symbolic link from $target_dir_name to tmpfs"
if ! ln -s "$target_tmpfs" "$target_dir"; then
	out 0 "[Error] Can't create symlink: $target_dir"
	
	back_sequence 4
fi

# Level 5: Run periodic synchronization in background
echo "You can unmount current directory by removing this file" > "$target_marker"
send_signal CONT
background_sync &
out 1 "[Info] Background synchronization started (PID=$!)"

# Run process (if set)
process_watcher &

exit 0
